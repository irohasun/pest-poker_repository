# PEST POKER - ゲームアプリ 仕様書

**アプリ名:** PEST POKER（ペストポーカー）  
**バージョン:** 1.9  
**作成日:** 2025年1月  
**ドキュメント種別:** 機能仕様書

---

## 目次

1. [概要](#1-概要)
2. [ゲームルール](#2-ゲームルール)
3. [画面設計](#3-画面設計)
4. [データ構造](#4-データ構造)
5. [UI/UXガイドライン](#5-uiuxガイドライン)
6. [技術仕様](#6-技術仕様)
7. [セキュリティとプライバシー](#7-セキュリティとプライバシー)
8. [エラーハンドリング](#8-エラーハンドリング)
9. [追加機能](#9-追加機能優先度別)
10. [テスト計画](#10-テスト計画)
11. [リリース計画](#11-リリース計画)
12. [付録](#12-付録)

---

## 1. 概要

### 1.1 アプリの目的

オフラインで1台のスマートフォンを共有し、複数人でブラフ系カードゲーム「PEST POKER（ペストポーカー）」を楽しむアプリ

### 1.2 基本コンセプト

- **アプリ名**: PEST POKER（害虫ポーカー）
- **物理カード不要**: スマホ1台があれば遊べる
- **スマホ共有型**: 順番に回して使用
- **プレイ人数**: 2〜6人
- **プレイ時間**: 約20分
- **ゲームジャンル**: ブラフ・心理戦

### 1.3 ゲームの目的

8種類の「害虫（PEST）」カードを押し付け合い、**敗者1人を決める**ゲーム

### 1.4 主な特徴

- オフライン完結（インターネット接続不要）
- シンプルなルール、深い戦略性
- 対面でのコミュニケーションを重視
- 覗き見防止機能搭載

---

## 2. ゲームルール

### 2.1 カード構成

**全64枚**: 8種類の生き物が各8枚ずつ

#### 害虫カードの種類

1. コウモリ 🦇 (Bat)
2. クモ 🕷️ (Spider)
3. サソリ 🦂 (Scorpion)
4. ネズミ 🐭 (Mouse)
5. カエル 🐸 (Frog)
6. ハエ 🪰 (Fly)
7. カメムシ 🪲 (Stink Bug)
8. ムカデ 🦟 (Centipede)

### 2.2 ゲームの準備

#### 手順

1. プレイヤー人数（2〜6人）を決定
2. 各プレイヤーの名前を入力
3. **2人プレイの場合、特殊ルール適用**（後述）
4. カードを均等に配布（余ったカードは使用しない）
5. 初期の親（出題者）を決定

#### カード配布枚数

| 人数 | 使用カード | 除外カード | 1人あたりの枚数 | 余りカード |
|------|-----------|-----------|----------------|-----------|
| 2人 | 54枚 | 10枚（ランダム）| 27枚 | 0枚 |
| 3人 | 64枚 | 0枚 | 21枚 | 1枚 |
| 4人 | 64枚 | 0枚 | 16枚 | 0枚 |
| 5人 | 64枚 | 0枚 | 12枚 | 4枚 |
| 6人 | 64枚 | 0枚 | 10枚 | 4枚 |

#### 2人プレイ時の特殊ルール

**問題点：**
- 2人で全64枚を使うと、相手の手札が完全に推測できてしまう
- 心理戦の要素が失われる

**解決策：**
1. ゲーム開始前に、**10枚をランダムに除外**
2. 残った54枚を27枚ずつ配布
3. 除外されたカードは誰にも見せない
4. どのカードが除外されたかは不明のまま進行

**戦略的意義：**
- 相手の手札が完全には分からない
- 除外カードの推測も戦略の一部
- ブラフが有効に機能する

**実装上の注意：**
- 除外カードは完全にランダム
- 除外カードの情報はゲーム終了まで非表示
- デバッグ用には除外カードを記録

### 2.3 ターンの流れ

#### フェーズ1: 出題者のアクション

1. **渡す相手を選択**
   - 自分以外のプレイヤーを1人選ぶ
   - 各プレイヤーの状態を考慮

2. **手札から1枚選択**
   - 自分の手札を確認
   - 押し付けたいカードを選ぶ

3. **宣言する生き物を選択**
   - 8種類から1つ選ぶ
   - **本当でも嘘でも良い**

#### フェーズ2: 回答者のアクション

回答者は以下の**3つの選択肢**から1つを選ぶ：

##### 選択肢A: 「本当」と判定

- カードをめくって確認
- 宣言が正しければ → カードは**出題者**の前に置かれる
  - 出題者がカードを引き取る
- 宣言が間違いなら → カードは**回答者**の前に置かれる
  - 回答者がカードを引き取る

##### 選択肢B: 「嘘」と判定

- カードをめくって確認
- 宣言が嘘なら → カードは**出題者**の前に置かれる
  - 出題者がカードを引き取る
- 宣言が本当なら → カードは**回答者**の前に置かれる
  - 回答者がカードを引き取る

##### 選択肢C: 他のプレイヤーに渡す

**⚠️ 重要：カード確認は必須**

1. **カードの確認（必須）**
   - 回答者は**必ず**カードの内容を確認する
   - 確認せずに渡すことはできない
   - 他のプレイヤーには見えないように配慮が必要
   - 確認画面で実際のカードと前の宣言の真偽が表示される
   
2. 次の相手を選択
   - **制約**: このターンで既に出題した人は除外
   - 渡せる相手がいない場合、必ず判定

3. 宣言する生き物を選択
   - 確認したカードの内容を基に、何を宣言するか決める
   - 前の宣言と同じでも違っても良い
   - 本当でも嘘でも良い

4. その相手が新しい回答者となる

**戦略的意義：**
- カードの内容を知った上で、どう宣言するかを決められる
- ポーカーフェイスが重要（確認後の表情管理）
- 本当のことを言うか、あえて嘘をつくかの駆け引き
- 確認した時点で判定には戻れない（一方通行）

#### フェーズ3: 結果確認と次のターン

1. **カード引き取りの確定**
   - カードが引き取られたプレイヤーの状態確認
   - 敗北判定のチェック

2. **次の出題者の決定**
   
   **🎯 重要ルール：次の出題者は必ずカードを引き取った人**
   
   - カードを引き取ったプレイヤーが次の出題者になる
   - これは必ず守らなければならないルール
   
   **具体例：**
   
   ```
   ケース1: 出題者が当てられた場合
   太郎（出題者）→ 花子に渡す
   花子が「本当」と判定 → 正解
   → カードは太郎の前に置かれる
   → 次の出題者は太郎
   ```
   
   ```
   ケース2: 回答者が外した場合
   太郎（出題者）→ 花子に渡す
   花子が「嘘」と判定 → 不正解（本当だった）
   → カードは花子の前に置かれる
   → 次の出題者は花子
   ```
   
   ```
   ケース3: 他の人に渡し続けた場合
   太郎 → 花子 → 次郎 → 三郎
   三郎が「本当」と判定 → 不正解
   → カードは三郎の前に置かれる
   → 次の出題者は三郎
   ```

3. **次のターンへ移行**
   - カードを引き取った人が新しい出題者としてターン開始
   - ゲームメイン画面に戻る

### 2.4 敗北条件

以下のいずれか1つを満たした時点で敗北：

1. **同じ種類のカードが4枚揃った**
   - 例: ゴキブリ×4

2. **8種類全てのカードが揃った**
   - 各種類1枚以上

3. **手札がない状態で出題できない**
   - 出題者のターンで手札が0枚の場合

#### 敗北条件の詳細判定

**【条件1・2の場合】**
- カードを「引き取った瞬間」に判定
- **引き取った人が敗北**

**【条件3の場合】**
- 出題者になった時に手札が0枚なら敗北
- **ただし例外：**
  - 最後の1枚を出して、相手に押し付けた場合は敗北しない
  - 次のターンは他の人が出題者になる
  - しかし、カードが戻ってきた場合（判定失敗）は敗北

#### エッジケースの処理

**ケース1: 同時敗北**
```
状況：
太郎が花子にカードを渡す
→ 花子が判定に失敗してカードを引き取る
→ 花子のクモが4枚になった

判定：
花子が敗北（カードを引き取った人）
```

**ケース2: 手札0枚 - 押し付け成功**
```
状況：
太郎（手札1枚）が花子にカードを渡す
→ 花子が判定ミス
→ カードが花子に残る

判定：
太郎の手札は0枚だが、カードを押し付けに成功
→ 太郎は敗北しない
→ 次のターンは花子が出題者
```

**ケース3: 手札0枚 - 押し付け失敗**
```
状況：
太郎（手札1枚）が花子にカードを渡す
→ 花子が正しく判定
→ カードが太郎に戻る

判定：
太郎（手札1枚）が再び出題者
→ しかし、すでに1枚出しているので手札0枚
→ 太郎は敗北
```

**ケース4: 全員が「渡す」を選択**
```
状況：
太郎 → 花子にカードを渡す（出題済み）
花子 → 次郎に渡す（出題済み）
次郎 → 三郎に渡す（出題済み）
三郎 → 全員が出題済みのため、誰にも渡せない

判定：
三郎は強制的に「本当」か「嘘」を判定
```

### 2.5 ゲーム終了

- 1人が敗北条件を満たした時点で終了
- その1人が**敗者**
- 残り全員が**勝者**

### 2.6 ゲームの戦略ポイント

#### 出題者の戦略

- 誰に押し付けるか
- 本当のことを言うか、嘘をつくか
- 自分の表情管理

#### 回答者の戦略

- 相手の表情を読む
- 場の状況から推理する
- リスクを取るか、安全に他の人に回すか

---

## 3. 画面設計

### 3.1 画面一覧

| No. | 画面名 | 説明 |
|-----|--------|------|
| 1 | タイトル画面 | アプリ起動時の最初の画面 |
| 2 | プレイヤー登録画面 | 人数と名前を入力 |
| 3 | ゲーム説明画面 | ルール説明 |
| 4 | 初期手札確認画面 | ゲーム開始時に全員が順番に手札確認 |
| 5 | ゲームメイン画面 | 現在の状況を表示 |
| 6 | 出題者：相手選択画面 | 渡す相手を選ぶ |
| 7 | 出題者：カード選択画面 | 手札から1枚選ぶ |
| 8 | 出題者：宣言選択画面 | 何を宣言するか選ぶ |
| 9 | 受け渡し演出画面 | カードが移動する演出 |
| 10 | 回答者：判定・場の状況確認画面 | 判定前に状況確認 |
| 11 | 回答者：カード確認画面 | 渡す場合のカード確認 |
| 12 | 回答者：相手選択画面 | 渡す相手を選ぶ |
| 13 | 回答者：宣言選択画面 | 何を宣言するか選ぶ |
| 14 | カードめくり演出画面 | 判定結果の表示 |
| 15 | 結果確認画面 | ターン結果のサマリー |
| 16 | ゲーム終了画面 | 勝敗結果の表示 |
| 17 | 一時停止画面 | ゲーム中断時 |

### 3.2 画面遷移図

```
[タイトル画面]
    ↓
[プレイヤー登録画面]
    ↓
[初期手札確認画面] (全員順番に)
    ↓
[ゲームメイン画面] ←─────────────┐
    ↓                                │
[出題者：相手選択]                    │
    ↓                                │
[出題者：カード選択]                  │
    ↓                                │
[出題者：宣言選択]                    │
    ↓                                │
[受け渡し演出]                       │
    ↓                                │
[回答者：判定・場の状況確認]          │
    ├→ [本当/嘘を選択]               │
    │     ↓                          │
    │  [カードめくり演出]             │
    │     ↓                          │
    │  [結果確認]                    │
    │     ↓                          │
    │  🎯 カードを引き取った人が      │
    │     次の出題者になる ──────────┘
    │
    └→ [他の人に渡す]
          ↓
       [カード確認]（必須）
          ↓
       [相手選択]
          ↓
       [宣言選択]
          ↓
       （回答者画面に戻る）
       
※ 最終的にカードを引き取った人が次の出題者
```

### 3.3 各画面の詳細仕様

#### 3.3.1 タイトル画面

**目的**: アプリの顔、ゲーム開始の入口

**表示要素**:
- ゲームタイトル（大きく、中央）
- ゲーム開始ボタン
- ルール説明ボタン
- 続きから再開ボタン（保存データがある場合のみ）

**レイアウト**:
```
┌─────────────────────┐
│                        │
│   [ゲームタイトル]      │
│      (ロゴ)            │
│                        │
│   ┌──────────────┐   │
│   │  ゲーム開始    │   │
│   └──────────────┘   │
│                        │
│   ┌──────────────┐   │
│   │  ルール説明    │   │
│   └──────────────┘   │
│                        │
│   ┌──────────────┐   │
│   │ 続きから再開   │   │
│   └──────────────┘   │
│                        │
└─────────────────────┘
```

**機能**:
- ゲーム開始 → プレイヤー登録画面へ
- ルール説明 → ゲーム説明画面へ
- 続きから再開 → 保存したゲーム状態を復元

#### 3.3.2 プレイヤー登録画面

**目的**: 参加人数と名前の入力

**表示要素**:
- 人数選択ボタン（2〜6人）
- プレイヤー名入力フィールド
- 開始ボタン

**レイアウト**:
```
┌─────────────────────┐
│ プレイヤー登録         │
├─────────────────────┤
│ 人数を選択:            │
│ [2] [3] [4] [5] [6]   │
│                        │
│ プレイヤー1:           │
│ [________________]     │
│                        │
│ プレイヤー2:           │
│ [________________]     │
│                        │
│ プレイヤー3:           │
│ [________________]     │
│                        │
│ ...                    │
│                        │
│   ┌──────────────┐   │
│   │   ゲーム開始   │   │
│   └──────────────┘   │
│                        │
│   [戻る]               │
└─────────────────────┘
```

**バリデーション**:
- 全員の名前が入力されていること
- 名前が重複していないこと
- 名前が空白でないこと

**エラーメッセージ**:
- 「すべてのプレイヤーの名前を入力してください」
- 「同じ名前は使用できません」

#### 3.3.3 初期手札確認画面

**目的**: ゲーム開始時に全員が順番に手札を確認

**フロー**:

1. **待機画面**
```
┌─────────────────────┐
│ 手札を確認してください  │
│                        │
│ 【太郎さんの番です】   │
│                        │
│ ⚠️ 他の人は見ないで！   │
│                        │
│   ┌──────────────┐   │
│   │  準備OK - タップ │   │
│   └──────────────┘   │
│                        │
└─────────────────────┘
```

2. **手札表示画面**
```
┌─────────────────────┐
│ 太郎さんの手札(12枚)   │
├─────────────────────┤
│ コウモリ ×2            │
│ [🦇] [🦇]              │
│                        │
│ クモ ×3                │
│ [🕷️] [🕷️] [🕷️]         │
│                        │
│ ハエ ×1                │
│ [🪰]                   │
│                        │
│ サソリ ×4              │
│ [🦂] [🦂] [🦂] [🦂]    │
│                        │
│ ネズミ ×2              │
│ [🐭] [🐭]              │
│                        │
│   ┌──────────────┐   │
│   │   確認完了     │   │
│   └──────────────┘   │
└─────────────────────┘
```

3. **次のプレイヤーへ**
```
┌─────────────────────┐
│ 次は花子さんです       │
│                        │
│ スマホを花子さんに     │
│ 渡してください         │
│                        │
│   ┌──────────────┐   │
│   │     次へ       │   │
│   └──────────────┘   │
│                        │
└─────────────────────┘
```

**セキュリティ機能**:
- 待機画面で2秒の遅延
- 大きな警告表示
- 確認完了後、即座に手札を非表示

#### 3.3.4 ゲームメイン画面

**目的**: 現在の状況を一覧表示

**表示要素**:
- ターン数
- ポーズボタン
- 全プレイヤーの状態
  - 名前
  - 手札枚数
  - 公開カード
  - 危険状態の警告
- 現在のプレイヤー
- アクションボタン

**レイアウト**:
```
┌─────────────────────────────────┐
│ターン: 3  [⏸ポーズ]              │
├─────────────────────────────────┤
│ 現在の状況:                      │
│                                  │
│ ▼太郎 (手札: 10枚)               │
│  ┌──┐           ┌──┐          │
│  │🦇│┐┐ 2      │🕷️│ 1       │
│  └──┘┘┘         └──┘          │
│                                  │
│  花子 (手札: 11枚)                │
│  ┌──┐                          │
│  │🐭│ 1                        │
│  └──┘                          │
│                                  │
│  次郎 (手札: 9枚) ⚠️             │
│  ┌──┐           ┌──┐          │
│  │🐸│┐┐┐ 3     │🦇│ 1       │  ← 危険！
│  └──┘┘┘┘       └──┘          │
│                                  │
│  三郎 (手札: 12枚)                │
│  引き取ったカードなし              │
│                                  │
├─────────────────────────────────┤
│ 【太郎さんの番です】              │
│                                  │
│   ┌────────────────────┐      │
│   │   カードを選ぶ        │      │
│   └────────────────────┘      │
│                                  │
└─────────────────────────────────┘
```

**危険状態の表示**:
- 同種3枚: ⚠️ 黄色
- 同種4枚or 7種揃い: 🚨 赤色

#### 3.3.5 出題者：相手選択画面

**目的**: カードを渡す相手を選ぶ

**表示要素**:
- プレイヤー一覧（自分以外）
- 各プレイヤーの状態（手札枚数、公開カード）
- 危険状態の警告
- 戻るボタン

**レイアウト**:
```
┌───────────────────────────────┐
│ 誰に渡しますか？               │
├───────────────────────────────┤
│                                │
│  ┌──────────────────────────┐ │
│  │ 花子                      │ │
│  │ 手札: 11枚                │ │
│  │ 公開:                     │ │
│  │  ┌──┐                   │ │
│  │  │🐭│ 1                 │ │
│  │  └──┘                   │ │
│  └──────────────────────────┘ │
│                                │
│  ┌──────────────────────────┐ │
│  │ 次郎 ⚠️                   │ │
│  │ 手札: 9枚                 │ │
│  │ 公開:                     │ │
│  │  ┌──┐      ┌──┐        │ │
│  │  │🐸│┐┐┐ 3 │🦇│ 1      │ │
│  │  └──┘┘┘┘   └──┘        │ │
│  └──────────────────────────┘ │
│                                │
│  ┌──────────────────────────┐ │
│  │ 三郎                      │ │
│  │ 手札: 12枚                │ │
│  │ 公開: なし                │ │
│  └──────────────────────────┘ │
│                                │
│   [戻る]                       │
└───────────────────────────────┘
```

**戦略ヒント**（オプション）:
- 危険状態のプレイヤーに押し付ける
- 手札が多い人を狙う

#### 3.3.6 出題者：カード選択画面

**目的**: 手札から押し付けるカードを選ぶ

**表示要素**:
- 現在のプレイヤー名
- 手札（種類別にグループ化）
- OKボタン
- キャンセルボタン

**レイアウト**:
```
┌─────────────────────┐
│ 太郎さん、カードを     │
│ 選んでください         │
├─────────────────────┤
│ あなたの手札:          │
│                        │
│ コウモリ ×2            │
│ [🦇] [🦇]              │
│                        │
│ クモ ×3                │
│ [🕷️] [🕷️] [🕷️]         │
│                        │
│ ハエ ×1                │
│ [🪰]                   │
│                        │
│ サソリ ×4              │
│ [🦂] [🦂] [🦂] [🦂]    │
│                        │
│   [OK] [キャンセル]    │
└─────────────────────┘
```

**インタラクション**:
- カードをタップで選択
- 選択したカードは拡大表示
- OK選択で次の画面へ遷移

**機能詳細**:
- 手札を種類別に表示
- カードをタップで選択状態にする
- 選択したカードは拡大・強調表示される
- 選択していない状態ではOKボタンは無効（グレーアウト）
- カード選択後、OKボタンが有効になる
- OKボタンをタップで確定し、次の画面へ遷移
- キャンセルボタンでゲームメイン画面に戻る

#### 3.3.7 出題者：宣言選択画面

**目的**: 何を宣言するか選ぶ

**表示要素**:
- 8種類の選択肢
- 渡す相手の確認表示
- 戻るボタン

**レイアウト**:
```
┌─────────────────────┐
│ 何だと宣言しますか？   │
│                        │
│ 花子さんに渡します     │
├─────────────────────┤
│                        │
│ [🦇 コウモリ]          │
│                        │
│ [🕷️ クモ]              │
│                        │
│ [🦂 サソリ]            │
│                        │
│ [🐭 ネズミ]            │
│                        │
│ [🐸 カエル]            │
│                        │
│ [🪰 ハエ]              │
│                        │
│ [🐛 カメムシ]          │
│                        │
│ [🦎 (8種類目)]         │
│                        │
│   [戻る]               │
└─────────────────────┘
```

**インタラクション**:
- ボタンをタップで選択
- 確認ダイアログ（オプション）
- 選択後、受け渡し演出へ

#### 3.3.8 受け渡し演出画面

**目的**: カードが移動する様子を演出

**演出内容**:
- カードが出題者から回答者へ移動
- 宣言内容の表示
- アニメーション（1.5秒）

**レイアウト**:
```
┌─────────────────────┐
│                        │
│   太郎 → 花子          │
│                        │
│      [🃏]              │
│   (カード移動)         │
│                        │
│ 「これはクモです」     │
│                        │
│                        │
└─────────────────────┘
```

↓ 演出終了後

```
┌─────────────────────┐
│ 花子さんにスマホを     │
│ 渡してください         │
│                        │
│   ┌──────────────┐   │
│   │     次へ       │   │
│   └──────────────┘   │
│                        │
└─────────────────────┘
```

**効果**:
- 効果音
- バイブレーション
- スキップ可能

#### 3.3.9 回答者：判定・場の状況確認画面

**目的**: 判断する前に場の状況を確認し、選択する

**表示要素**:
- 宣言内容
- 出題者名
- **場の状況（全プレイヤー）** ← 新規追加
- 3つの選択肢ボタン

**レイアウト**:
```
┌─────────────────────────────────┐
│花子さんの番です [⏸]              │
├─────────────────────────────────┤
│ 宣言内容:                        │
│ 「これはクモです」               │
│   - 太郎さんより                 │
├─────────────────────────────────┤
│ 📊 場の状況:                     │
│                                  │
│ ▼ 太郎 (手札: 9枚)               │
│   ┌──┐                          │
│   │🦇│┐┐ 2                      │  ← カード重なり表示
│   └──┘┘┘                        │
│   ┌──┐                          │
│   │🕷️│ 1                        │
│   └──┘                          │
│                                  │
│ ▶ 花子 (手札: 11枚) ←あなた      │
│   ┌──┐                          │
│   │🐭│ 1                        │
│   └──┘                          │
│                                  │
│ ▶ 次郎 (手札: 9枚) ⚠️           │
│   ┌──┐                          │
│   │🐸│┐┐┐ 3                    │  ← 危険！
│   └──┘┘┘┘                      │
│   ┌──┐                          │
│   │🦇│ 1                        │
│   └──┘                          │
│                                  │
│ ▶ 三郎 (手札: 12枚)              │
│   引き取ったカードなし            │
│                                  │
│ (スクロール可能)                 │
├─────────────────────────────────┤
│   [本当だと思う]                 │
│   [嘘だと思う]                   │
│   [他の人に渡す]                 │
└─────────────────────────────────┘
```

**カード表示の詳細**:
```
実装イメージ：

1枚の場合:
┌──────┐
│ 🦇   │
│コウモリ│ 1
└──────┘

2枚の場合:
┌──────┐
│ 🦇   │┐
│コウモリ│┐ 2
└──────┘┘

3枚の場合:
┌──────┐
│ 🐸   │┐┐
│ カエル │┐┐ 3
└──────┘┘┘

4枚の場合（危険）:
┌──────┐
│ 🐸   │┐┐┐
│ カエル │┐┐┐ 4 ⚠️
└──────┘┘┘┘
```

**ビジュアル仕様**:
- カードは実際のデザイン（ミニサイズ）
- 重なりは右下にずらして表示（オフセット: 4px）
- 数字は大きく、太字で表示
- 4枚の場合は赤く点滅
- カードをタップで拡大表示（詳細確認）

**重要ポイント**:
- 必ず場の状況を確認できる
- 誰が危険か一目で分かる
- 自分の位置を明示
- スクロールで全員確認可能

**選択肢の詳細**:

1. **「本当だと思う」「嘘だと思う」**
   - タップでカードめくり演出画面へ遷移

2. **「他の人に渡す」**
   - タップでカード確認画面へ遷移
   - **⚠️ 注意**: このボタンを選択すると、必ずカードを確認することになる
   - カード確認後は判定に戻れない（一方通行）
   - 渡せる相手がいない場合はボタンが無効化（グレーアウト）

#### 3.3.10 カードめくり演出画面

**目的**: 判定結果を劇的に表示

**演出フロー**:

1. **判定宣言**
```
┌─────────────────────┐
│                        │
│  花子さんの判定:       │
│  「嘘だと思う」        │
│                        │
│      [🃏]              │
│                        │
│                        │
└─────────────────────┘
```

2. **カードめくり**
```
┌─────────────────────┐
│                        │
│      [🃏]              │
│   (めくり中...)        │
│                        │
│       ↓                │
│                        │
│      [🕷️]              │
│                        │
└─────────────────────┘
```

3. **結果表示**
```
┌─────────────────────┐
│  ❌ 判定失敗！          │
│                        │
│  宣言: クモ            │
│  実際: クモ            │
│                        │
│  カードは花子さんへ    │
│                        │
│   ┌──────────────┐   │
│   │     次へ       │   │
│   └──────────────┘   │
└─────────────────────┘
```

**演出時間**: 合計2〜3秒（スキップ可能）

#### 3.3.11 結果確認画面

**目的**: ターンの結果をまとめて表示

**表示要素**:
- ターン番号
- 結果サマリー
- 更新された場の状況
- 敗北条件の警告
- 次のターンへボタン

**レイアウト**:
```
┌───────────────────────────────┐
│ ターン3の結果                  │
├───────────────────────────────┤
│ 花子さんが                     │
│ クモのカードを                 │
│ 引き取りました                 │
│                                │
│ 🎯 次の出題者: 花子さん        │  ← 明示的に表示
│                                │
│ 現在の状況:                    │
│                                │
│ 太郎 (手札: 9枚)               │
│ ┌──┐        ┌──┐            │
│ │🦇│┐┐ 2   │🕷️│ 1         │
│ └──┘┘┘      └──┘            │
│                                │
│ ▼花子 (手札: 11枚) ⚠️ ← 次の出題者│
│ ┌──┐        ┌──┐            │
│ │🐭│ 1     │🕷️│ 1         │
│ └──┘        └──┘            │
│                                │
│ 次郎 (手札: 9枚)               │
│ ┌──┐        ┌──┐            │
│ │🐸│┐┐┐ 3  │🦇│ 1         │
│ └──┘┘┘┘    └──┘            │
│                                │
│ 三郎 (手札: 12枚)              │
│ 引き取ったカードなし            │
│                                │
│   ┌────────────────────┐    │
│   │   次のターンへ        │    │
│   │  (花子さんの番)       │    │
│   └────────────────────┘    │
└───────────────────────────────┘
```

**重要な表示要素**:
- カードを引き取った人の名前を強調
- 「次の出題者」を明示的に表示
- 該当プレイヤーに▼マークで視覚的に示す
- ボタンのテキストにも次の出題者名を表示

**敗北条件チェック**:
- 自動でチェック
- 該当する場合は即座にゲーム終了画面へ

#### 3.3.12 回答者：カード確認画面（渡す場合・必須）

**目的**: カードの内容を確認する（必須プロセス）

**画面1: 確認準備**

**レイアウト**:
```
┌─────────────────────┐
│ ⚠️ 重要な注意         │
│                        │
│ これから実際のカードを │
│ 確認します             │
│                        │
│ 他のプレイヤーには     │
│ 見えないように         │
│ 注意してください       │
│                        │
│ 🤫 ポーカーフェイスを  │
│    保ちましょう        │
│                        │
│   [確認する]           │
│   [戻る]               │
└─────────────────────┘
```

**セキュリティ機能**:
- 2秒間の遅延（覗き見防止）
- 画面輝度を最低限に（オプション）
- 大きな警告表示

---

**画面2: カード表示**

**レイアウト**:
```
┌─────────────────────┐
│ ⚠️ 他の人は見ないで！   │
│                        │
│  実際のカードは...     │
│                        │
│      [🕷️]              │
│   「クモ」でした       │
│                        │
│  前の宣言:「クモ」     │
│  → 本当でした ✓        │
│                        │
│ これから次の人に       │
│ 何を宣言するか決めます │
│                        │
│   [次へ]               │
└─────────────────────┘
```

**表示情報**:
- 実際のカード（絵柄 + 名前）
- 前の宣言内容
- 真偽の判定（本当でした/嘘でした）

**機能**:
- 確認後、即座に次の画面へ遷移
- 戻るボタンなし（確認後は取り消せない）
- 自動タイマー（オプション、30秒後に自動で次へ）

**重要な注意事項**:
- この画面を見た後は、判定には戻れない
- 必ず次の人に渡す流れになる
- 表情管理が重要なポイント

**戦略的意義**:
- カードの内容を知った上で、最適な宣言を選べる
- ポーカーフェイスの維持が勝負の鍵
- 本当のことを言うか、嘘をつくかの心理戦

#### 3.3.13 回答者：相手選択画面（渡す場合）

**目的**: 次に渡す相手を選ぶ

**表示要素**:
- 渡せるプレイヤーのみ表示
- 既に出題した人は除外
- 各プレイヤーの状態

**レイアウト**:
```
┌─────────────────────┐
│ 誰に渡しますか？       │
├─────────────────────┤
│ ❌ 太郎 (出題済)       │
│                        │
│  ┌────────────────┐  │
│  │ ✅ 次郎 ⚠️        │  │
│  │ 手札: 9枚         │  │
│  │ 公開: 🐸×3 🦇×1 │  │
│  └────────────────┘  │
│                        │
│  ┌────────────────┐  │
│  │ ✅ 三郎           │  │
│  │ 手札: 12枚        │  │
│  │ 公開: なし        │  │
│  └────────────────┘  │
│                        │
│   [戻る]               │
└─────────────────────┘
```

**制約**:
- このターンで既に出題した人は選択不可
- グレーアウトで明示

#### 3.3.14 ゲーム終了画面

**目的**: 勝敗結果の表示

**表示要素**:
- 敗者の表示
- 敗北理由
- 最終的なカード状況
- リプレイボタン
- タイトルに戻るボタン

**レイアウト**:
```
┌─────────────────────┐
│   ゲーム終了！         │
├─────────────────────┤
│                        │
│  敗者: 次郎さん        │
│                        │
│  敗北理由:             │
│  カエルが4枚揃った     │
│                        │
│  最終状況:             │
│  🐸×4 🦇×1 🕷️×2     │
│                        │
├─────────────────────┤
│  勝者:                 │
│  太郎、花子、三郎      │
│                        │
│  ┌────────────────┐  │
│  │   もう一度      │  │
│  └────────────────┘  │
│                        │
│  ┌────────────────┐  │
│  │ タイトルへ      │  │
│  └────────────────┘  │
│                        │
└─────────────────────┘
```

**2人プレイ時の追加表示**:
```
┌─────────────────────┐
│   ゲーム終了！         │
├─────────────────────┤
│  敗者: 花子さん        │
│  ...（上記と同じ）     │
├─────────────────────┤
│ 🎴 除外カード（10枚）  │
│                        │
│  🦇×2  🕷️×1  🦂×1   │
│  🐭×2  🐸×1  🪰×2   │
│  🐛×1                 │
│                        │
│  これらのカードは       │
│  ゲームに使われません   │
│  でした                │
│                        │
│  [詳細を見る]          │
└─────────────────────┘
```

**追加要素（オプション）**:
- ターン数
- プレイ時間
- 統計情報
- **2人プレイ時：除外カード一覧**

#### 3.3.15 一時停止画面

**目的**: ゲームの中断・再開

**表示要素**:
- 現在のゲーム状況
- ゲームに戻るボタン
- ルール確認ボタン
- ゲーム終了ボタン

**レイアウト**:
```
┌─────────────────────┐
│   ⏸ 一時停止中         │
├─────────────────────┤
│                        │
│  現在: ターン5         │
│  次: 太郎さん          │
│                        │
│  ┌────────────────┐  │
│  │ ゲームに戻る    │  │
│  └────────────────┘  │
│                        │
│  ┌────────────────┐  │
│  │ ルールを見る    │  │
│  └────────────────┘  │
│                        │
│  ┌────────────────┐  │
│  │ ゲームを終了    │  │
│  └────────────────┘  │
│                        │
└─────────────────────┘
```

**機能**:
- ゲームに戻る → 中断前の画面へ
- ルールを見る → ルール説明表示
- ゲームを終了 → 確認後タイトルへ

---

## 4. データ構造

### 4.1 ゲーム状態管理

```javascript
gameState = {
  // ゲーム基本情報
  gameId: "uuid-string",
  status: "playing", // "setup", "playing", "paused", "finished"
  turnNumber: 1,
  createdAt: "2025-01-15T10:00:00Z",
  
  // プレイヤー情報
  players: [
    {
      id: 0,
      name: "太郎",
      handCount: 10,
      hand: ["bat", "bat", "spider", "fly", ...], // 実際の手札
      openCards: {
        "bat": 2,
        "spider": 1
      },
      isEliminated: false
    },
    {
      id: 1,
      name: "花子",
      handCount: 11,
      hand: ["mouse", "spider", ...],
      openCards: {
        "mouse": 1
      },
      isEliminated: false
    },
    // ...
  ],
  
  // 現在のターン情報
  currentTurn: {
    questioner: 0, // プレイヤーID
    card: "spider", // 選択されたカード
    declaredAs: "bat", // 宣言内容
    answerer: 1, // 現在の回答者
    playersInTurn: [0], // このターンで出題した人のリスト
    history: [
      {
        player: 0,
        action: "question",
        to: 1,
        declared: "bat"
      },
      // ...
    ]
  },
  
  // 全体の履歴
  gameHistory: [
    {
      turn: 1,
      questioner: "太郎",
      answerer: "花子",
      declared: "クモ",
      actual: "コウモリ",
      judgment: "嘘",
      result: "失敗",
      cardGoesTo: "花子"
    },
    {
      turn: 2,
      questioner: "花子",
      answerer: "次郎",
      declared: "ネズミ",
      actual: "ネズミ",
      judgment: "本当",
      result: "成功",
      cardGoesTo: "花子"
    },
    // ...
  ],
  
  // カード情報
  deck: {
    "bat": 8,
    "spider": 8,
    "scorpion": 8,
    "mouse": 8,
    "frog": 8,
    "fly": 8,
    "stinkbug": 8,
    "creature8": 8
  },
  
  // 2人プレイ用：除外カード（ゲーム終了まで非表示）
  excludedCards: ["bat", "spider", ...], // 2人プレイ時のみ10枚
  
  remainingCards: {
    "bat": 4, // 未配布・未公開のカード数
    "spider": 5,
    "scorpion": 7,
    "mouse": 6,
    "frog": 3,
    "fly": 6,
    "stinkbug": 7,
    "creature8": 8
  }
}
```

### 4.2 プレイヤーデータ構造

```javascript
player = {
  id: 0, // プレイヤーID
  name: "太郎", // プレイヤー名
  handCount: 10, // 手札枚数
  hand: [ // 手札の実際のカード
    "bat",
    "bat",
    "spider",
    "spider",
    "spider",
    "fly",
    "scorpion",
    "scorpion",
    "scorpion",
    "scorpion"
  ],
  openCards: { // 公開されたカード（カードスタック表示に使用）
    "bat": 2,      // コウモリ2枚 → ┌──┐
                   //               │🦇│┐┐ 2
                   //               └──┘┘┘
    "spider": 1    // クモ1枚     → ┌──┐
                   //               │🕷️│ 1
                   //               └──┘
  },
  isEliminated: false, // 敗北フラグ
  statistics: { // 統計情報（オプション）
    questionsAsked: 5,
    questionsAnswered: 4,
    liesSuccessful: 2,
    liesFailed: 1,
    truthsSuccessful: 1,
    truthsFailed: 1
  }
}
```

### 4.3 ターンデータ構造

```javascript
turn = {
  questioner: 0, // 出題者のプレイヤーID
  card: "spider", // 選択されたカード
  declaredAs: "bat", // 宣言内容
  answerer: 1, // 現在の回答者のプレイヤーID
  playersInTurn: [0, 1], // このターンで出題した人のリスト
  history: [ // このターン内の履歴
    {
      player: 0,
      action: "question", // "question" or "pass"
      to: 1,
      declared: "bat",
      timestamp: "2025-01-15T10:05:00Z"
    },
    {
      player: 1,
      action: "pass",
      to: 2,
      declared: "bat",
      checkedCard: false,
      timestamp: "2025-01-15T10:06:00Z"
    }
  ]
}
```

### 4.4 LocalStorage保存形式

```javascript
// 保存するデータ
const savedData = {
  version: "1.0",
  savedAt: "2025-01-15T10:30:00Z",
  gameState: { /* 上記のgameState */ }
};

// 保存
localStorage.setItem('bluffCardGame_savedGame', JSON.stringify(savedData));

// 読み込み
const loadedData = JSON.parse(localStorage.getItem('bluffCardGame_savedGame'));
```

### 4.5 設定データ構造

```javascript
settings = {
  sound: {
    enabled: true,
    volume: 0.7
  },
  vibration: {
    enabled: true
  },
  animation: {
    speed: "normal", // "slow", "normal", "fast"
    enabled: true
  },
  privacy: {
    dimScreenOnHandView: false // 手札確認時に画面を暗くする
  },
  language: "ja" // 多言語対応用
}
```

---

## 5. UI/UXガイドライン

### 5.1 デザイン原則

#### 基本方針

1. **シンプル**: 複雑な装飾を避け、機能を明確に
2. **直感的**: 説明不要で操作できる
3. **反応的**: 即座にフィードバック
4. **一貫性**: 全画面で統一されたデザイン

#### ユーザビリティの優先順位

1. 操作の分かりやすさ
2. 情報の見やすさ
3. エラーの防止
4. 美しさ・楽しさ

### 5.2 カラースキーム

#### メインカラー

| 用途 | 色 | 16進数 | 使用場所 |
|------|---|--------|----------|
| プライマリー | ダークブルー | #2C3E50 | ヘッダー、メインボタン |
| セカンダリー | レッド | #E74C3C | 危険、警告、キャンセル |
| アクセント | ライトブルー | #3498DB | 選択中、強調 |
| 背景 | ライトグレー | #ECF0F1 | 画面背景 |
| テキスト | ダークグレー | #2C3E50 | 本文テキスト |
| 警告 | オレンジ | #F39C12 | 注意喚起 |
| 成功 | グリーン | #27AE60 | 成功メッセージ |
| 無効 | グレー | #95A5A6 | 無効なボタン |

#### カードの色

各生き物に固有の色を割り当て、視覚的に区別しやすく：

| 生き物 | 色 | 16進数 |
|--------|---|--------|
| コウモリ | 紫 | #9B59B6 |
| クモ | 黒 | #34495E |
| サソリ | 茶色 | #D35400 |
| ネズミ | グレー | #7F8C8D |
| カエル | 緑 | #27AE60 |
| ハエ | 青 | #3498DB |
| カメムシ | 黄緑 | #F1C40F |
| (8種類目) | ピンク | #E91E63 |

### 5.3 タイポグラフィ

#### フォント

**推奨フォント**: 
- 日本語: Noto Sans JP
- 英数字: Roboto

**フォントサイズ**:

| 要素 | サイズ | 太さ | 用途 |
|------|--------|------|------|
| 大見出し | 24px | Bold | タイトル |
| 中見出し | 20px | Semi-Bold | セクションタイトル |
| 小見出し | 18px | Semi-Bold | サブタイトル |
| 本文 | 16px | Regular | 通常テキスト |
| 小文字 | 14px | Regular | 補足情報 |
| ボタン | 18px | Bold | ボタンラベル |

### 5.4 スペーシング

**基本単位**: 8px

| 用途 | サイズ |
|------|--------|
| 最小マージン | 8px |
| 標準マージン | 16px |
| 大きいマージン | 24px |
| セクション間 | 32px |
| パディング（小） | 8px |
| パディング（中） | 16px |
| パディング（大） | 24px |

### 5.5 ボタンデザイン

#### プライマリーボタン

```css
.primary-button {
  background: #3498DB;
  color: white;
  padding: 16px 32px;
  border-radius: 8px;
  font-size: 18px;
  font-weight: bold;
  min-width: 200px;
  min-height: 56px;
}

.primary-button:hover {
  background: #2980B9;
}

.primary-button:active {
  background: #21618C;
}
```

#### セカンダリーボタン

```css
.secondary-button {
  background: transparent;
  color: #3498DB;
  border: 2px solid #3498DB;
  padding: 14px 30px;
  border-radius: 8px;
  font-size: 16px;
}
```

#### 危険ボタン

```css
.danger-button {
  background: #E74C3C;
  color: white;
  padding: 16px 32px;
  border-radius: 8px;
}
```

### 5.6 アニメーション

#### 基本方針

- **短く**: 1〜2秒以内
- **スキップ可能**: 必須
- **意味のある**: 情報を伝える
- **60fps**: 滑らか

#### 主要アニメーション

| アニメーション | 時間 | イージング | 説明 |
|---------------|------|-----------|------|
| カード移動 | 1.5s | ease-in-out | カードが人から人へ |
| カードめくり | 1.0s | ease-out | カードの表裏反転 |
| 画面遷移 | 0.3s | ease | フェードイン/アウト |
| ボタンフィードバック | 0.1s | ease | タップ時の反応 |
| モーダル表示 | 0.2s | ease-out | ダイアログ表示 |

#### CSS例

```css
/* カード移動 */
.card-move {
  transition: transform 1.5s ease-in-out;
}

/* カードめくり */
.card-flip {
  transition: transform 1s ease-out;
  transform-style: preserve-3d;
}

/* 画面遷移 */
.screen-transition {
  transition: opacity 0.3s ease;
}
```

### 5.7 レスポンシブデザイン

#### 対応画面サイズ

| デバイス | 画面サイズ | 優先度 |
|----------|-----------|--------|
| iPhone SE | 320×568px | 最小サポート |
| iPhone 12/13 | 390×844px | 主要ターゲット |
| iPhone Pro Max | 428×926px | 主要ターゲット |
| iPad | 768×1024px | オプション |

#### ブレークポイント

```css
/* 小型スマートフォン */
@media (max-width: 374px) {
  /* フォントサイズを小さく */
}

/* 標準スマートフォン */
@media (min-width: 375px) and (max-width: 767px) {
  /* デフォルト */
}

/* タブレット */
@media (min-width: 768px) {
  /* レイアウト調整 */
}
```

### 5.8 アクセシビリティ

#### カラーコントラスト

- **WCAG AA準拠**: コントラスト比 4.5:1以上
- テキストと背景の組み合わせをチェック

#### タッチターゲット

- **最小サイズ**: 44×44px
- ボタン間のスペース: 最低8px

#### 色覚異常対応

- 色だけでなく、**アイコン・模様**でも区別
- 各カードに固有の**シンボル**を追加

例：
- コウモリ: 🦇 + 三角形
- クモ: 🕷️ + 円形
- サソリ: 🦂 + 四角形

#### フォントサイズ

- **最小サイズ**: 14px
- ユーザーがサイズ調整可能（オプション）

---

## 6. 技術仕様

### 6.1 採用技術スタック

#### 📱 フロントエンド: React Native + TypeScript + Expo

**選定理由**:
- クロスプラットフォーム（iOS/Android）
- TypeScriptによる型安全性
- Expoによる迅速な開発・テスト
- 実機での即座の確認が可能
- ネイティブアプリの高いパフォーマンス

**技術構成**:
```
コア:
- React Native 0.73+
- TypeScript 5.0+
- Expo SDK 50+

ナビゲーション:
- React Navigation 6+
- @react-navigation/native
- @react-navigation/stack

状態管理:
- Redux Toolkit + TypeScript
- @reduxjs/toolkit
- react-redux

UI/アニメーション:
- React Native Reanimated 3+
- React Native Gesture Handler
- Expo Linear Gradient

永続化:
- AsyncStorage
- Expo SecureStore

開発ツール:
- Expo Go (実機テスト)
- Expo Dev Client
- React Native Debugger
```

#### 🗄️ バックエンド: Supabase

**選定理由**:
- リアルタイムデータベース
- 認証機能（将来のオンライン対応用）
- Row Level Security
- 無料枠が充実
- TypeScript SDKの完全サポート

**技術構成**:
```
Database:
- PostgreSQL (Supabase管理)

SDK:
- @supabase/supabase-js

機能:
- Database: ゲームデータ保存
- Auth: 将来のユーザー認証用
- Storage: 将来の画像保存用
- Realtime: 将来のオンライン対戦用
```

#### 🐳 開発環境: Docker

**選定理由**:
- 環境の統一
- 依存関係の管理
- チーム開発での一貫性

**構成**:
```
Docker Compose:
- Node.js コンテナ
- Supabase ローカル環境
- 開発用データベース

コンテナ:
- app: React Native開発環境
- supabase: ローカルSupabase
- postgres: 開発用DB
```

### 6.2 プロジェクト構造（React Native + TypeScript）

```
bluff-card-game/
├── .expo/                      # Expo設定
├── .docker/                    # Docker設定
│   ├── Dockerfile
│   └── docker-compose.yml
├── src/
│   ├── components/             # React コンポーネント
│   │   ├── common/
│   │   │   ├── Button.tsx
│   │   │   ├── Card.tsx
│   │   │   ├── Modal.tsx
│   │   │   └── index.ts
│   │   ├── screens/
│   │   │   ├── TitleScreen.tsx
│   │   │   ├── PlayerSetupScreen.tsx
│   │   │   ├── GameMainScreen.tsx
│   │   │   ├── CardSelectionScreen.tsx
│   │   │   ├── OpponentSelectionScreen.tsx
│   │   │   ├── DeclarationSelectionScreen.tsx
│   │   │   ├── JudgmentScreen.tsx
│   │   │   ├── ResultScreen.tsx
│   │   │   ├── GameEndScreen.tsx
│   │   │   └── index.ts
│   │   └── animations/
│   │       ├── CardMove.tsx
│   │       ├── CardFlip.tsx
│   │       └── index.ts
│   ├── navigation/             # ナビゲーション
│   │   ├── AppNavigator.tsx
│   │   ├── types.ts
│   │   └── index.ts
│   ├── store/                  # Redux store
│   │   ├── slices/
│   │   │   ├── gameSlice.ts
│   │   │   ├── playerSlice.ts
│   │   │   └── index.ts
│   │   ├── store.ts
│   │   └── hooks.ts
│   ├── services/               # 外部サービス
│   │   ├── supabase.ts
│   │   ├── storage.ts
│   │   └── index.ts
│   ├── utils/                  # ユーティリティ
│   │   ├── gameLogic.ts
│   │   ├── cardUtils.ts
│   │   ├── validation.ts
│   │   └── index.ts
│   ├── hooks/                  # カスタムフック
│   │   ├── useGameState.ts
│   │   ├── useSound.ts
│   │   ├── useVibration.ts
│   │   └── index.ts
│   ├── constants/              # 定数
│   │   ├── cards.ts
│   │   ├── config.ts
│   │   ├── colors.ts
│   │   └── index.ts
│   ├── types/                  # TypeScript型定義
│   │   ├── game.ts
│   │   ├── player.ts
│   │   ├── card.ts
│   │   └── index.ts
│   ├── assets/                 # アセット
│   │   ├── images/
│   │   ├── sounds/
│   │   └── fonts/
│   └── styles/                 # スタイル
│       ├── theme.ts
│       ├── colors.ts
│       └── typography.ts
├── supabase/                   # Supabase設定
│   ├── migrations/
│   ├── functions/
│   └── config.toml
├── App.tsx                     # エントリーポイント
├── app.json                    # Expo設定
├── babel.config.js
├── tsconfig.json               # TypeScript設定
├── package.json
├── .env                        # 環境変数
├── .env.example
├── .gitignore
├── docker-compose.yml          # Docker Compose
└── README.md
```

### 6.3 開発環境セットアップ

#### Docker環境の構築

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: .docker/Dockerfile
    volumes:
      - .:/app
      - /app/node_modules
    ports:
      - "19000:19000"  # Expo Dev Server
      - "19001:19001"  # Expo Dev Server (Webpack)
      - "19002:19002"  # Expo Metro Bundler
    environment:
      - EXPO_DEVTOOLS_LISTEN_ADDRESS=0.0.0.0
      - REACT_NATIVE_PACKAGER_HOSTNAME=192.168.1.100  # ホストマシンのIPアドレス
    command: npm start
    networks:
      - app-network

  supabase:
    image: supabase/postgres:15.1.0.117
    ports:
      - "54322:5432"
    environment:
      POSTGRES_PASSWORD: your-super-secret-password
      POSTGRES_DB: postgres
    volumes:
      - supabase-data:/var/lib/postgresql/data
    networks:
      - app-network

volumes:
  supabase-data:

networks:
  app-network:
    driver: bridge
```

**.docker/Dockerfile**:
```dockerfile
FROM node:18-alpine

WORKDIR /app

# 必要なパッケージをインストール
RUN apk add --no-cache \
    git \
    python3 \
    make \
    g++

# Expo CLIをグローバルインストール
RUN npm install -g expo-cli eas-cli

# package.jsonとpackage-lock.jsonをコピー
COPY package*.json ./

# 依存関係をインストール
RUN npm install

# アプリケーションコードをコピー
COPY . .

EXPOSE 19000 19001 19002

CMD ["npm", "start"]
```

#### セットアップ手順

**1. リポジトリのクローン**
```bash
git clone https://github.com/your-repo/bluff-card-game.git
cd bluff-card-game
```

**2. 環境変数の設定**
```bash
cp .env.example .env
# .envファイルを編集してSupabaseの認証情報を設定
```

**.env.example**:
```
# Supabase
SUPABASE_URL=http://localhost:54322
SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key

# Expo
EXPO_PUBLIC_API_URL=http://192.168.1.100:3000
```

**3. Dockerコンテナの起動**
```bash
# Dockerコンテナをビルド・起動
docker-compose up -d

# ログの確認
docker-compose logs -f app
```

**4. Supabaseのセットアップ**
```bash
# Supabase CLIのインストール（ホストマシン）
npm install -g supabase

# Supabaseプロジェクトの初期化
supabase init

# ローカルSupabaseの起動
supabase start

# マイグレーションの実行
supabase db push
```

**5. 実機での確認（Expo Go使用）**

**方法A: QRコードでスキャン**
```bash
# Expo Dev Serverが起動している状態で
# ターミナルに表示されるQRコードをExpo Goアプリでスキャン
```

**方法B: 同じWi-Fiネットワーク経由**
```bash
# ホストマシンのIPアドレスを確認
ipconfig  # Windows
ifconfig  # Mac/Linux

# .envファイルのREACT_NATIVE_PACKAGER_HOSTNAMEを更新
# 例: 192.168.1.100
```

**方法C: トンネリング（ネットワーク制限がある場合）**
```bash
npx expo start --tunnel
```

**6. 開発用コマンド**
```bash
# Expo Dev Serverの起動
npm start

# iOS Simulatorで起動
npm run ios

# Android Emulatorで起動
npm run android

# 型チェック
npm run type-check

# Lint
npm run lint

# テスト
npm test
```

### 6.4 依存パッケージ

**package.json**:
```json
{
  "name": "pest-poker",
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "type-check": "tsc --noEmit",
    "lint": "eslint . --ext .ts,.tsx",
    "test": "jest"
  },
  "dependencies": {
    "expo": "~50.0.0",
    "expo-status-bar": "~1.11.1",
    "react": "18.2.0",
    "react-native": "0.73.0",
    "react-native-reanimated": "~3.6.0",
    "react-native-gesture-handler": "~2.14.0",
    "react-native-screens": "~3.29.0",
    "react-native-safe-area-context": "4.8.0",
    "@react-navigation/native": "^6.1.9",
    "@react-navigation/stack": "^6.3.20",
    "@reduxjs/toolkit": "^2.0.1",
    "react-redux": "^9.0.4",
    "@supabase/supabase-js": "^2.39.0",
    "@react-native-async-storage/async-storage": "1.21.0",
    "expo-linear-gradient": "~12.7.0",
    "expo-haptics": "~12.8.0",
    "expo-av": "~13.10.0",
    "@stripe/stripe-react-native": "^0.37.2",
    "stripe": "^14.10.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "~18.2.45",
    "@types/react-native": "~0.73.0",
    "@typescript-eslint/eslint-plugin": "^6.15.0",
    "@typescript-eslint/parser": "^6.15.0",
    "eslint": "^8.56.0",
    "eslint-config-expo": "^7.0.0",
    "jest": "^29.7.0",
    "typescript": "^5.3.3"
  }
}
```

### 6.5 TypeScript設定

**tsconfig.json**:
```json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "jsx": "react-native",
    "lib": ["esnext"],
    "types": ["react-native", "jest"],
    "paths": {
      "@/*": ["./src/*"],
      "@components/*": ["./src/components/*"],
      "@screens/*": ["./src/components/screens/*"],
      "@store/*": ["./src/store/*"],
      "@utils/*": ["./src/utils/*"],
      "@types/*": ["./src/types/*"],
      "@constants/*": ["./src/constants/*"]
    }
  },
  "include": ["**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

#### 保存タイミング

```javascript
// 1. 各ターン終了時
const saveTurnEnd = (gameState) => {
  localStorage.setItem('gameState', JSON.stringify(gameState));
};

// 2. ポーズ時
const handlePause = (gameState) => {
  gameState.status = 'paused';
  localStorage.setItem('gameState', JSON.stringify(gameState));
};

// 3. アプリ非アクティブ時（beforeunload）
window.addEventListener('beforeunload', () => {
  const gameState = store.getState().game;
  localStorage.setItem('gameState', JSON.stringify(gameState));
});
```

#### 復帰処理

```javascript
// アプリ起動時
const loadSavedGame = () => {
  const saved = localStorage.getItem('gameState');
  if (saved) {
    try {
      const gameState = JSON.parse(saved);
      // バージョンチェック
      if (gameState.version === CURRENT_VERSION) {
        return gameState;
      }
    } catch (error) {
      console.error('Failed to load saved game', error);
    }
  }
  return null;
};
```

### 6.6 データ永続化とSupabase実装

#### Supabaseクライアントの設定

**src/services/supabase.ts**:
```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/supabase';

const supabaseUrl = process.env.SUPABASE_URL || 'http://localhost:54322';
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY || '';

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey, {
  auth: {
    storage: AsyncStorage,
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: false,
  },
});
```

#### データベーススキーマ

**supabase/migrations/001_initial_schema.sql**:
```sql
-- ゲームセッションテーブル
CREATE TABLE game_sessions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  status TEXT NOT NULL DEFAULT 'playing',
  turn_number INTEGER NOT NULL DEFAULT 1,
  player_count INTEGER NOT NULL,
  game_data JSONB NOT NULL,
  CONSTRAINT valid_status CHECK (status IN ('setup', 'playing', 'paused', 'finished'))
);

-- プレイヤーテーブル
CREATE TABLE players (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  game_session_id UUID REFERENCES game_sessions(id) ON DELETE CASCADE,
  player_index INTEGER NOT NULL,
  name TEXT NOT NULL,
  hand_count INTEGER NOT NULL DEFAULT 0,
  hand JSONB NOT NULL DEFAULT '[]',
  open_cards JSONB NOT NULL DEFAULT '{}',
  is_eliminated BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ゲーム履歴テーブル
CREATE TABLE game_history (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  game_session_id UUID REFERENCES game_sessions(id) ON DELETE CASCADE,
  turn_number INTEGER NOT NULL,
  questioner TEXT NOT NULL,
  answerer TEXT NOT NULL,
  declared TEXT NOT NULL,
  actual TEXT NOT NULL,
  judgment TEXT NOT NULL,
  result TEXT NOT NULL,
  card_goes_to TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- インデックス
CREATE INDEX idx_game_sessions_status ON game_sessions(status);
CREATE INDEX idx_players_game_session ON players(game_session_id);
CREATE INDEX idx_game_history_session ON game_history(game_session_id);

-- 更新時刻の自動更新
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_game_sessions_updated_at
  BEFORE UPDATE ON game_sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();
```

#### ローカルストレージ（AsyncStorage）の実装

**src/services/storage.ts**:
```typescript
import AsyncStorage from '@react-native-async-storage/async-storage';
import { GameState } from '@/types/game';

const STORAGE_KEYS = {
  GAME_STATE: '@bluff_game:game_state',
  SETTINGS: '@bluff_game:settings',
  GAME_HISTORY: '@bluff_game:game_history',
};

export class StorageService {
  // ゲーム状態の保存
  static async saveGameState(gameState: GameState): Promise<void> {
    try {
      const jsonValue = JSON.stringify({
        version: '1.0',
        savedAt: new Date().toISOString(),
        gameState,
      });
      await AsyncStorage.setItem(STORAGE_KEYS.GAME_STATE, jsonValue);
    } catch (error) {
      console.error('Failed to save game state:', error);
      throw error;
    }
  }

  // ゲーム状態の読み込み
  static async loadGameState(): Promise<GameState | null> {
    try {
      const jsonValue = await AsyncStorage.getItem(STORAGE_KEYS.GAME_STATE);
      if (jsonValue === null) return null;

      const data = JSON.parse(jsonValue);
      
      // バージョンチェック
      if (data.version !== '1.0') {
        console.warn('Incompatible game state version');
        return null;
      }

      return data.gameState;
    } catch (error) {
      console.error('Failed to load game state:', error);
      return null;
    }
  }

  // ゲーム状態の削除
  static async clearGameState(): Promise<void> {
    try {
      await AsyncStorage.removeItem(STORAGE_KEYS.GAME_STATE);
    } catch (error) {
      console.error('Failed to clear game state:', error);
      throw error;
    }
  }

  // 設定の保存
  static async saveSettings(settings: any): Promise<void> {
    try {
      const jsonValue = JSON.stringify(settings);
      await AsyncStorage.setItem(STORAGE_KEYS.SETTINGS, jsonValue);
    } catch (error) {
      console.error('Failed to save settings:', error);
      throw error;
    }
  }

  // 設定の読み込み
  static async loadSettings(): Promise<any> {
    try {
      const jsonValue = await AsyncStorage.getItem(STORAGE_KEYS.SETTINGS);
      return jsonValue ? JSON.parse(jsonValue) : null;
    } catch (error) {
      console.error('Failed to load settings:', error);
      return null;
    }
  }
}
```

#### Supabaseへのゲーム保存（将来のオンライン対応用）

**src/services/gameService.ts**:
```typescript
import { supabase } from './supabase';
import { GameState, Player } from '@/types/game';

export class GameService {
  // ゲームセッションの作成
  static async createGameSession(
    playerCount: number,
    gameData: GameState
  ): Promise<string> {
    try {
      const { data, error } = await supabase
        .from('game_sessions')
        .insert({
          player_count: playerCount,
          game_data: gameData as any,
          status: 'playing',
        })
        .select()
        .single();

      if (error) throw error;
      return data.id;
    } catch (error) {
      console.error('Failed to create game session:', error);
      throw error;
    }
  }

  // ゲーム状態の更新
  static async updateGameSession(
    sessionId: string,
    gameData: Partial<GameState>
  ): Promise<void> {
    try {
      const { error } = await supabase
        .from('game_sessions')
        .update({
          game_data: gameData as any,
          updated_at: new Date().toISOString(),
        })
        .eq('id', sessionId);

      if (error) throw error;
    } catch (error) {
      console.error('Failed to update game session:', error);
      throw error;
    }
  }

  // ゲーム履歴の追加
  static async addGameHistory(
    sessionId: string,
    turn: any
  ): Promise<void> {
    try {
      const { error } = await supabase.from('game_history').insert({
        game_session_id: sessionId,
        ...turn,
      });

      if (error) throw error;
    } catch (error) {
      console.error('Failed to add game history:', error);
      throw error;
    }
  }

  // ゲームセッションの取得
  static async getGameSession(sessionId: string): Promise<any> {
    try {
      const { data, error } = await supabase
        .from('game_sessions')
        .select('*')
        .eq('id', sessionId)
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Failed to get game session:', error);
      throw error;
    }
  }
}
```

#### 自動保存機能

**src/hooks/useAutoSave.ts**:
```typescript
import { useEffect, useRef } from 'react';
import { useAppSelector } from '@/store/hooks';
import { StorageService } from '@/services/storage';

export const useAutoSave = () => {
  const gameState = useAppSelector((state) => state.game);
  const saveTimeoutRef = useRef<NodeJS.Timeout>();

  useEffect(() => {
    // デバウンス処理：1秒後に保存
    if (saveTimeoutRef.current) {
      clearTimeout(saveTimeoutRef.current);
    }

    saveTimeoutRef.current = setTimeout(async () => {
      if (gameState.status === 'playing') {
        try {
          await StorageService.saveGameState(gameState);
          console.log('Game state auto-saved');
        } catch (error) {
          console.error('Auto-save failed:', error);
        }
      }
    }, 1000);

    return () => {
      if (saveTimeoutRef.current) {
        clearTimeout(saveTimeoutRef.current);
      }
    };
  }, [gameState]);
};
```

#### ゲーム復帰機能

**src/hooks/useGameRecovery.ts**:
```typescript
import { useEffect, useState } from 'react';
import { useAppDispatch } from '@/store/hooks';
import { StorageService } from '@/services/storage';
import { restoreGameState } from '@/store/slices/gameSlice';
import { GameState } from '@/types/game';

export const useGameRecovery = () => {
  const dispatch = useAppDispatch();
  const [hasSavedGame, setHasSavedGame] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkForSavedGame();
  }, []);

  const checkForSavedGame = async () => {
    try {
      const savedGame = await StorageService.loadGameState();
      setHasSavedGame(!!savedGame);
    } catch (error) {
      console.error('Failed to check for saved game:', error);
    } finally {
      setLoading(false);
    }
  };

  const recoverGame = async (): Promise<boolean> => {
    try {
      const savedGame = await StorageService.loadGameState();
      if (savedGame) {
        dispatch(restoreGameState(savedGame));
        return true;
      }
      return false;
    } catch (error) {
      console.error('Failed to recover game:', error);
      return false;
    }
  };

  const clearSavedGame = async (): Promise<void> => {
    try {
      await StorageService.clearGameState();
      setHasSavedGame(false);
    } catch (error) {
      console.error('Failed to clear saved game:', error);
      throw error;
    }
  };

  return {
    hasSavedGame,
    loading,
    recoverGame,
    clearSavedGame,
  };
};
```

### 6.7 Stripe決済システムの実装

#### Stripeの選定理由

**メリット：**
- 世界標準の決済プラットフォーム
- セキュアな決済処理
- 買い切り型（One-time payment）に最適
- React Native用SDKが充実
- Supabaseとの連携が容易

#### アーキテクチャ

```
React Native App
    ↓
Stripe SDK (Client)
    ↓
Supabase Edge Functions (Backend)
    ↓
Stripe API (Server)
```

#### 環境変数設定

**.env**:
```bash
# Stripe公開可能キー（クライアント側で使用）
EXPO_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_xxxxx

# Stripeシークレットキー（サーバー側のみ）
STRIPE_SECRET_KEY=sk_test_xxxxx

# 商品ID
STRIPE_PRODUCT_AD_REMOVAL=prod_xxxxx
```

#### Stripeクライアントの初期化

**src/services/stripe.ts**:
```typescript
import { StripeProvider, useStripe } from '@stripe/stripe-react-native';

const STRIPE_PUBLISHABLE_KEY = process.env.EXPO_PUBLIC_STRIPE_PUBLISHABLE_KEY || '';

// Appのルートで初期化
export const StripeWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  return (
    <StripeProvider publishableKey={STRIPE_PUBLISHABLE_KEY}>
      {children}
    </StripeProvider>
  );
};
```

#### Supabase Edge Function（決済バックエンド）

**supabase/functions/create-payment-intent/index.ts**:
```typescript
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import Stripe from 'https://esm.sh/stripe@14.10.0?target=deno';

const stripe = new Stripe(Deno.env.get('STRIPE_SECRET_KEY') || '', {
  apiVersion: '2023-10-16',
  httpClient: Stripe.createFetchHttpClient(),
});

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // CORS対応
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const { amount, currency, metadata } = await req.json();

    // Payment Intentの作成
    const paymentIntent = await stripe.paymentIntents.create({
      amount, // 日本円の場合は300円 = 300
      currency, // 'jpy'
      automatic_payment_methods: {
        enabled: true,
      },
      metadata, // ユーザーID、商品IDなどを記録
    });

    return new Response(
      JSON.stringify({ 
        clientSecret: paymentIntent.client_secret 
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }
});
```

#### 決済フローの実装

**src/services/paymentService.ts**:
```typescript
import { useStripe } from '@stripe/stripe-react-native';
import { supabase } from './supabase';

export const usePayment = () => {
  const { initPaymentSheet, presentPaymentSheet } = useStripe();

  // 広告除去の購入
  const purchaseAdRemoval = async (userId: string) => {
    try {
      // 1. バックエンドからPayment Intentを取得
      const { data, error } = await supabase.functions.invoke('create-payment-intent', {
        body: {
          amount: 300, // 300円
          currency: 'jpy',
          metadata: {
            userId,
            productId: 'ad_removal',
            productName: '広告除去',
          },
        },
      });

      if (error) throw error;

      const { clientSecret } = data;

      // 2. Payment Sheetの初期化
      const { error: initError } = await initPaymentSheet({
        merchantDisplayName: 'PEST POKER',
        paymentIntentClientSecret: clientSecret,
        defaultBillingDetails: {
          // ユーザー情報があれば設定
        },
        returnURL: 'bluffgame://payment-success',
      });

      if (initError) throw initError;

      // 3. Payment Sheetの表示
      const { error: presentError } = await presentPaymentSheet();

      if (presentError) {
        // ユーザーがキャンセルした場合
        if (presentError.code === 'Canceled') {
          return { success: false, canceled: true };
        }
        throw presentError;
      }

      // 4. 支払い成功 - データベースに記録
      await recordPurchase(userId, 'ad_removal', clientSecret);

      return { success: true, canceled: false };
    } catch (error) {
      console.error('Payment error:', error);
      return { success: false, error };
    }
  };

  return { purchaseAdRemoval };
};

// 購入履歴の記録
const recordPurchase = async (
  userId: string,
  productId: string,
  transactionId: string
) => {
  const { error } = await supabase.from('purchases').insert({
    user_id: userId,
    product_id: productId,
    transaction_id: transactionId,
    purchased_at: new Date().toISOString(),
    platform: 'stripe',
  });

  if (error) {
    console.error('Failed to record purchase:', error);
    throw error;
  }
};
```

#### 購入状態の確認

**src/hooks/usePurchaseStatus.ts**:
```typescript
import { useEffect, useState } from 'react';
import { supabase } from '@/services/supabase';

export const usePurchaseStatus = (userId: string) => {
  const [adRemovalPurchased, setAdRemovalPurchased] = useState(false);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkPurchaseStatus();
  }, [userId]);

  const checkPurchaseStatus = async () => {
    try {
      const { data, error } = await supabase
        .from('purchases')
        .select('*')
        .eq('user_id', userId)
        .eq('product_id', 'ad_removal')
        .single();

      if (error && error.code !== 'PGRST116') {
        // PGRST116 = レコードなし（購入していない）
        throw error;
      }

      setAdRemovalPurchased(!!data);
    } catch (error) {
      console.error('Failed to check purchase status:', error);
    } finally {
      setLoading(false);
    }
  };

  const refreshPurchaseStatus = () => {
    setLoading(true);
    checkPurchaseStatus();
  };

  return {
    adRemovalPurchased,
    loading,
    refreshPurchaseStatus,
  };
};
```

#### 購入画面の実装

**src/components/screens/PurchaseScreen.tsx**:
```typescript
import React from 'react';
import { View, Text, TouchableOpacity, ActivityIndicator, Alert } from 'react-native';
import { usePayment } from '@/services/paymentService';
import { usePurchaseStatus } from '@/hooks/usePurchaseStatus';

export const PurchaseScreen: React.FC = () => {
  const { purchaseAdRemoval } = usePayment();
  const { adRemovalPurchased, loading, refreshPurchaseStatus } = usePurchaseStatus('user-id');
  const [purchasing, setPurchasing] = useState(false);

  const handlePurchase = async () => {
    setPurchasing(true);
    
    const result = await purchaseAdRemoval('user-id');
    
    if (result.success) {
      Alert.alert(
        '購入完了',
        '広告が除去されました。ありがとうございます！',
        [{ text: 'OK', onPress: () => refreshPurchaseStatus() }]
      );
    } else if (result.canceled) {
      Alert.alert('キャンセル', '購入がキャンセルされました。');
    } else {
      Alert.alert(
        'エラー',
        '購入に失敗しました。もう一度お試しください。'
      );
    }
    
    setPurchasing(false);
  };

  if (loading) {
    return <ActivityIndicator size="large" />;
  }

  if (adRemovalPurchased) {
    return (
      <View style={styles.container}>
        <Text style={styles.title}>✅ 広告除去済み</Text>
        <Text style={styles.message}>
          ご購入ありがとうございます！
        </Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>💰 広告を除去</Text>
      <Text style={styles.price}>¥300（買い切り）</Text>
      <Text style={styles.description}>
        すべての広告が永久に非表示になります
      </Text>
      
      <TouchableOpacity
        style={styles.button}
        onPress={handlePurchase}
        disabled={purchasing}
      >
        {purchasing ? (
          <ActivityIndicator color="white" />
        ) : (
          <Text style={styles.buttonText}>購入する</Text>
        )}
      </TouchableOpacity>
    </View>
  );
};
```

#### データベーススキーマ（購入履歴）

**supabase/migrations/002_purchases.sql**:
```sql
-- 購入履歴テーブル
CREATE TABLE purchases (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL,
  product_id TEXT NOT NULL,
  transaction_id TEXT NOT NULL UNIQUE,
  purchased_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  platform TEXT NOT NULL DEFAULT 'stripe',
  amount INTEGER,
  currency TEXT DEFAULT 'jpy',
  metadata JSONB DEFAULT '{}',
  
  CONSTRAINT valid_platform CHECK (platform IN ('stripe', 'apple', 'google'))
);

-- インデックス
CREATE INDEX idx_purchases_user_id ON purchases(user_id);
CREATE INDEX idx_purchases_product_id ON purchases(product_id);
CREATE INDEX idx_purchases_transaction_id ON purchases(transaction_id);

-- Row Level Security
ALTER TABLE purchases ENABLE ROW LEVEL SECURITY;

-- ユーザーは自分の購入履歴のみ閲覧可能
CREATE POLICY "Users can view their own purchases"
  ON purchases FOR SELECT
  USING (auth.uid() = user_id);

-- 挿入は認証されたユーザーのみ
CREATE POLICY "Authenticated users can insert purchases"
  ON purchases FOR INSERT
  WITH CHECK (auth.uid() = user_id);
```

#### テスト用のStripe設定

**開発環境：**
```typescript
// テストカード番号
const TEST_CARD = {
  number: '4242424242424242',
  expMonth: 12,
  expYear: 2034,
  cvc: '123',
};

// テストモードでの動作確認
// 実際の決済は行われない
```

#### 本番環境への移行

1. **Stripeダッシュボードで商品作成**
   - 商品名：広告除去
   - 価格：¥300
   - タイプ：One-time payment

2. **本番キーの設定**
   ```bash
   # .env.production
   EXPO_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_xxxxx
   STRIPE_SECRET_KEY=sk_live_xxxxx
   ```

3. **Webhookの設定**
   - 決済成功時の通知
   - 返金時の処理

### 6.8 状態管理（Redux Toolkit）

```javascript
// gameSlice.js
import { createSlice } from '@reduxjs/toolkit';

const gameSlice = createSlice({
  name: 'game',
  initialState: {
    status: 'setup', // 'setup', 'playing', 'paused', 'finished'
    turnNumber: 0,
    players: [],
    currentTurn: null,
    history: [],
  },
  reducers: {
    setupGame: (state, action) => {
      state.players = action.payload.players;
      state.status = 'playing';
      // カード配布ロジック
    },
    selectCard: (state, action) => {
      state.currentTurn.card = action.payload;
    },
    makeJudgment: (state, action) => {
      // 判定ロジック
    },
    endTurn: (state) => {
      state.turnNumber += 1;
      // 次のターンの準備
    },
    checkDefeat: (state) => {
      // 敗北条件チェック
    },
  },
});

export const { 
  setupGame, 
  selectCard, 
  makeJudgment, 
  endTurn, 
  checkDefeat 
} = gameSlice.actions;

export default gameSlice.reducer;
```

### 6.5 ゲームロジック

#### カード配布

```typescript
// cardUtils.ts
const CARD_TYPES: CardType[] = [
  'bat', 'spider', 'scorpion', 'mouse',
  'frog', 'fly', 'stinkbug', 'centipede'
];

export const createDeck = (): CardType[] => {
  const deck: CardType[] = [];
  CARD_TYPES.forEach(type => {
    for (let i = 0; i < 8; i++) {
      deck.push(type);
    }
  });
  return shuffle(deck);
};

export const distributeCards = (numPlayers: number) => {
  let deck = createDeck(); // 64枚
  let excludedCards: CardType[] = [];
  
  // 2人プレイの特殊ルール：10枚をランダムに除外
  if (numPlayers === 2) {
    const shuffledDeck = shuffle([...deck]);
    excludedCards = shuffledDeck.slice(0, 10); // 最初の10枚を除外
    deck = shuffledDeck.slice(10); // 残り54枚を使用
    
    console.log('2-player mode: 10 cards excluded');
    // デバッグ用：除外カードを記録（本番では非表示）
    console.log('Excluded cards:', excludedCards);
  }
  
  const cardsPerPlayer = Math.floor(deck.length / numPlayers);
  const players: Player[] = [];
  
  for (let i = 0; i < numPlayers; i++) {
    const hand = deck.splice(0, cardsPerPlayer);
    players.push({
      id: i,
      name: '',
      color: '',
      hand,
      handCount: hand.length,
      openCards: {},
      isEliminated: false,
      statistics: {
        questionsAsked: 0,
        questionsAnswered: 0,
        liesSuccessful: 0,
        liesFailed: 0,
        truthsSuccessful: 0,
        truthsFailed: 0,
      }
    });
  }
  
  return { 
    players, 
    remainingCards: deck, // 配り切れなかったカード
    excludedCards, // 2人プレイ時の除外カード
    totalCardsUsed: numPlayers === 2 ? 54 : 64
  };
};

const shuffle = <T>(array: T[]): T[] => {
  const shuffled = [...array];
  // Fisher-Yates shuffle
  for (let i = shuffled.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
  }
  return shuffled;
};

// 2人プレイ用：除外カードの統計情報（ゲーム終了後に表示）
export const getExcludedCardStats = (excludedCards: CardType[]) => {
  const stats: Record<CardType, number> = {} as Record<CardType, number>;
  
  excludedCards.forEach(card => {
    stats[card] = (stats[card] || 0) + 1;
  });
  
  return stats;
};
```

#### 敗北判定

```javascript
// gameLogic.js
export const checkDefeat = (player) => {
  const { openCards, handCount } = player;
  
  // 条件1: 同じ種類が4枚
  for (const [type, count] of Object.entries(openCards)) {
    if (count >= 4) {
      return {
        defeated: true,
        reason: 'same_type',
        type
      };
    }
  }
  
  // 条件2: 8種類全て
  if (Object.keys(openCards).length >= 8) {
    return {
      defeated: true,
      reason: 'all_types'
    };
  }
  
  // 条件3: 手札なし（この関数を呼ぶ前にチェック）
  if (handCount === 0) {
    return {
      defeated: true,
      reason: 'no_cards'
    };
  }
  
  return { defeated: false };
};

// ターン終了後の処理
export const endTurn = (gameState, cardRecipientId) => {
  // 1. カードを引き取ったプレイヤーを次の出題者に設定
  const nextQuestioner = cardRecipientId;
  
  // 2. 敗北判定
  const recipient = gameState.players.find(p => p.id === cardRecipientId);
  const defeatCheck = checkDefeat(recipient);
  
  if (defeatCheck.defeated) {
    // ゲーム終了
    return {
      ...gameState,
      status: 'finished',
      loser: cardRecipientId,
      defeatReason: defeatCheck.reason,
    };
  }
  
  // 3. 次のターンへ
  return {
    ...gameState,
    currentQuestioner: nextQuestioner, // 🎯 カードを引き取った人が次の出題者
    turnNumber: gameState.turnNumber + 1,
    currentTurn: {
      questioner: nextQuestioner,
      card: null,
      declaredAs: null,
      answerer: null,
      playersInTurn: [],
      history: [],
    },
  };
};

// 判定処理の完全な例
export const processJudgment = (gameState, isCorrect) => {
  const { questioner, answerer, card } = gameState.currentTurn;
  
  // カードを引き取る人を決定
  const cardRecipient = isCorrect ? questioner : answerer;
  
  // カードを該当プレイヤーの公開カードに追加
  const updatedPlayers = gameState.players.map(player => {
    if (player.id === cardRecipient) {
      return {
        ...player,
        openCards: {
          ...player.openCards,
          [card]: (player.openCards[card] || 0) + 1,
        },
      };
    }
    return player;
  });
  
  // ターン終了処理（次の出題者設定を含む）
  return endTurn(
    {
      ...gameState,
      players: updatedPlayers,
    },
    cardRecipient
  );
};
```

### 6.8 パフォーマンス要件

| 指標 | 目標値 |
|------|--------|
| 初回ロード時間 | 3秒以内 |
| アクション応答時間 | 0.1秒以内 |
| アニメーションFPS | 60fps |
| メモリ使用量 | 50MB以内 |
| バッテリー消費 | 最小限 |

#### 最適化手法（TypeScript版）

```typescript
// 1. React.memo でコンポーネントの再レンダリング防止
import React from 'react';
import { CardType } from '@/types/card';

interface CardProps {
  type: CardType;
  onPress: (type: CardType) => void;
}

export const Card = React.memo<CardProps>(({ type, onPress }) => {
  return (
    <TouchableOpacity onPress={() => onPress(type)}>
      <Text>{type}</Text>
    </TouchableOpacity>
  );
});

// 2. useCallback でコールバック関数の再生成防止
import { useCallback } from 'react';
import { useAppDispatch } from '@/store/hooks';
import { selectCard } from '@/store/slices/gameSlice';

const handleCardSelect = useCallback((card: CardType) => {
  dispatch(selectCard(card));
}, [dispatch]);

// 3. useMemo で重い計算のメモ化
const sortedPlayers = useMemo(() => {
  return players.sort((a, b) => a.handCount - b.handCount);
}, [players]);

// 4. React Native ReanimatedでアニメーションをUIスレッドで実行
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withTiming,
} from 'react-native-reanimated';

const CardAnimated: React.FC = () => {
  const translateY = useSharedValue(0);
  
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ translateY: translateY.value }],
  }));
  
  return <Animated.View style={animatedStyle} />;
};
```

### 6.9 エラーハンドリング（TypeScript版）

```typescript
// エラーバウンダリー
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

interface Props {
  children: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export class ErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
    };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo): void {
    console.error('Game Error:', error, errorInfo);
    // エラーログ送信（オプション）
    // Sentry.captureException(error);
  }

  handleReload = (): void => {
    this.setState({ hasError: false, error: null });
  };

  render(): ReactNode {
    if (this.state.hasError) {
      return (
        <View style={styles.container}>
          <Text style={styles.title}>エラーが発生しました</Text>
          <Text style={styles.message}>
            {this.state.error?.message || '不明なエラー'}
          </Text>
          <TouchableOpacity 
            style={styles.button}
            onPress={this.handleReload}
          >
            <Text style={styles.buttonText}>再試行</Text>
          </TouchableOpacity>
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  message: {
    fontSize: 16,
    marginBottom: 24,
    textAlign: 'center',
  },
  button: {
    backgroundColor: '#3498DB',
    paddingHorizontal: 32,
    paddingVertical: 16,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
});
```

  render() {
    if (this.state.hasError) {
      return (
        <div>
          <h1>エラーが発生しました</h1>
          <button onClick={() => window.location.reload()}>
            再読み込み
          </button>
        </div>
      );
    }

    return this.props.children;
  }
}
```

---

## 7. セキュリティとプライバシー

### 7.1 覗き見防止

#### 実装策

**1. 警告表示**
```jsx
<div className="privacy-warning">
  <h1>⚠️ 他の人は見ないでください！</h1>
  <p>準備ができたらタップしてください</p>
</div>
```

**2. 画面輝度調整（オプション）**
```javascript
// 手札確認時に輝度を最低に
const dimScreen = () => {
  document.body.style.filter = 'brightness(0.3)';
};

const restoreBrightness = () => {
  document.body.style.filter = 'brightness(1)';
};
```

**3. タイムラグ**
```javascript
// 警告表示後2秒待機
const showHand = async () => {
  setShowWarning(true);
  await delay(2000);
  setShowWarning(false);
  setShowHandCards(true);
};
```

**4. 即座に非表示**
```javascript
const handleConfirm = () => {
  setShowHandCards(false);
  // 次の画面へ
};
```

### 7.2 データプライバシー

#### 基本方針

- **完全オフライン**: サーバーへのデータ送信なし
- **ローカルストレージのみ**: すべてのデータは端末内
- **個人情報収集なし**: 名前以外の情報は不要
- **匿名使用可能**: ニックネームでOK

#### データの扱い

```javascript
// プライバシーポリシー
const PRIVACY_POLICY = {
  dataCollection: 'なし',
  dataStorage: 'ローカル端末のみ',
  dataSharing: 'なし',
  analytics: 'なし（オプション）',
};
```

### 7.3 不正防止（将来のオンライン対応用）

#### 基本設計

- カード情報はクライアント側で管理
- 状態の整合性チェック
- タイムスタンプで不正検出

---

## 8. エラーハンドリング

### 8.1 想定エラーと対応

| エラー種類 | 原因 | 対応策 |
|-----------|------|--------|
| アプリクラッシュ | メモリ不足、バグ | 自動保存から復帰 |
| 誤操作 | ユーザーミス | 確認ダイアログ |
| データ破損 | ストレージエラー | エラー表示、新規ゲーム促進 |
| 不正な状態 | ロジックバグ | デバッグログ、初期化 |
| LocalStorage満杯 | ストレージ制限 | 古いデータ削除 |

### 8.2 確認ダイアログが必要な操作

重要な操作には必ず確認ダイアログを表示：

```javascript
const confirmActions = [
  'ゲーム終了',
  'タイトルに戻る',
  '保存データの削除',
  '設定のリセット',
];

const showConfirmDialog = (action) => {
  return new Promise((resolve) => {
    // ダイアログ表示
    // OKなら resolve(true)
    // キャンセルなら resolve(false)
  });
};
```

### 8.3 エラーメッセージ

#### 分かりやすいメッセージ

**悪い例**:
```
Error: State corruption detected
```

**良い例**:
```
ゲームデータに問題が発生しました。
新しいゲームを開始してください。
```

#### エラー表示コンポーネント

```jsx
const ErrorMessage = ({ title, message, onRetry, onHome }) => (
  <div className="error-container">
    <h2>{title}</h2>
    <p>{message}</p>
    <div className="error-actions">
      {onRetry && <Button onClick={onRetry}>もう一度</Button>}
      {onHome && <Button onClick={onHome}>タイトルへ</Button>}
    </div>
  </div>
);
```

---

## 9. 追加機能（優先度別）

### 9.1 必須機能（MVP - Minimum Viable Product）

**実装必須**:
- ✅ 基本ゲームフロー
- ✅ プレイヤー登録
- ✅ カード配布・管理
- ✅ ターン進行
- ✅ 勝敗判定
- ✅ 場の状況確認
- ✅ 覗き見防止

### 9.2 優先度：高

**早期実装推奨**:
- ⭐ 一時停止・再開
- ⭐ データ保存・復帰
- ⭐ ルール説明
- ⭐ 基本アニメーション
- ⭐ 効果音
- ⭐ 確認ダイアログ
- 💰 **マネタイゼーション（Stripe決済）**
  - 広告表示（AdMob）
  - 広告除去の購入（¥300買い切り）

### 9.3 優先度：中

**余裕があれば実装**:
- 📊 ゲーム履歴表示
- 📊 統計情報（嘘の成功率など）
- ⚙️ カスタムルール（カード枚数調整）
- 🎨 テーマ変更（ダークモード）
- 🌐 多言語対応
- 🔊 サウンドエフェクトのカスタマイズ

### 9.4 優先度：低

**将来的に検討**:
- 🎬 リプレイ機能
- 🤖 AI対戦モード
- 🏆 実績システム
- 👤 アバター選択
- 📱 オンライン対戦
- 👥 フレンド機能

### 9.5 機能詳細

#### ゲーム履歴表示

```jsx
const GameHistory = ({ history }) => (
  <div className="history">
    <h3>ゲーム履歴</h3>
    {history.map((turn, index) => (
      <div key={index} className="history-item">
        <span>ターン{turn.turn}</span>
        <span>{turn.questioner} → {turn.answerer}</span>
        <span>宣言: {turn.declared}</span>
        <span>実際: {turn.actual}</span>
        <span className={turn.result === '成功' ? 'success' : 'failure'}>
          {turn.result}
        </span>
      </div>
    ))}
  </div>
);
```

#### 統計情報

```jsx
const PlayerStatistics = ({ player }) => (
  <div className="statistics">
    <h4>{player.name}の統計</h4>
    <ul>
      <li>出題回数: {player.stats.questionsAsked}</li>
      <li>回答回数: {player.stats.questionsAnswered}</li>
      <li>嘘の成功率: {player.stats.liesSuccessful / (player.stats.liesSuccessful + player.stats.liesFailed) * 100}%</li>
      <li>見抜き成功率: {player.stats.truthsSuccessful / (player.stats.truthsSuccessful + player.stats.truthsFailed) * 100}%</li>
    </ul>
  </div>
);
```

#### カスタムルール

```jsx
const CustomRules = ({ onApply }) => {
  const [cardsPerPlayer, setCardsPerPlayer] = useState(12);
  const [defeatCondition, setDefeatCondition] = useState('standard');
  
  return (
    <div className="custom-rules">
      <h3>カスタムルール</h3>
      <label>
        1人あたりのカード枚数:
        <input 
          type="number" 
          value={cardsPerPlayer}
          onChange={(e) => setCardsPerPlayer(e.target.value)}
          min={5}
          max={32}
        />
      </label>
      <label>
        敗北条件:
        <select 
          value={defeatCondition}
          onChange={(e) => setDefeatCondition(e.target.value)}
        >
          <option value="standard">標準（4枚 or 8種類）</option>
          <option value="quick">クイック（3枚 or 6種類）</option>
          <option value="long">ロング（5枚 or 8種類）</option>
        </select>
      </label>
      <button onClick={() => onApply({ cardsPerPlayer, defeatCondition })}>
        適用
      </button>
    </div>
  );
};
```

---

## 10. テスト計画

### 10.1 ユニットテスト

#### テスト対象

```javascript
// cardUtils.test.js
describe('Card Utils', () => {
  test('createDeck creates 64 cards', () => {
    const deck = createDeck();
    expect(deck.length).toBe(64);
  });
  
  test('each card type appears 8 times', () => {
    const deck = createDeck();
    CARD_TYPES.forEach(type => {
      const count = deck.filter(card => card === type).length;
      expect(count).toBe(8);
    });
  });
});

// gameLogic.test.js
describe('Game Logic', () => {
  test('checkDefeat detects 4 same cards', () => {
    const player = {
      openCards: { bat: 4 },
      handCount: 5
    };
    const result = checkDefeat(player);
    expect(result.defeated).toBe(true);
    expect(result.reason).toBe('same_type');
  });
  
  test('checkDefeat detects all 8 types', () => {
    const player = {
      openCards: {
        bat: 1, spider: 1, scorpion: 1, mouse: 1,
        frog: 1, fly: 1, stinkbug: 1, creature8: 1
      },
      handCount: 5
    };
    const result = checkDefeat(player);
    expect(result.defeated).toBe(true);
    expect(result.reason).toBe('all_types');
  });
});
```

### 10.2 統合テスト

#### テストシナリオ

**シナリオ1: 基本フロー**
```
1. タイトル画面表示
2. プレイヤー登録（3人）
3. 手札確認（全員）
4. ゲーム開始
5. 1ターン実行
   - 相手選択
   - カード選択
   - 宣言選択
   - 判定
6. 結果確認
7. 敗北判定
```

**シナリオ2: 他の人に渡す**
```
1. 回答者がカードを受け取る
2. 「他の人に渡す」を選択
3. カード確認（任意）
4. 次の相手を選択
5. 宣言選択
6. 次の回答者へ
```

**シナリオ3: ゲーム終了**
```
1. プレイヤーが敗北条件を満たす
2. ゲーム終了画面表示
3. 結果確認
4. もう一度/タイトルへ
```

### 10.3 ユーザビリティテスト

#### テスト項目

**初心者テスト**:
- ルール説明を読まずに理解できるか
- 初回プレイで迷わず操作できるか
- エラーから回復できるか

**プレイヤー人数別テスト**:
- 2人でスムーズに遊べるか
- 6人でも混乱しないか
- 各人数での所要時間

**覗き見防止テスト**:
- 実際に覗き見できないか
- 警告は効果的か
- 改善の余地はないか

#### テスト手順

```
1. テストプレイヤー募集（3〜6人）
2. ルール説明なしでプレイ
3. プレイ中の観察
   - 迷った箇所を記録
   - 誤操作を記録
   - 所要時間を計測
4. フィードバック収集
   - アンケート
   - インタビュー
5. 改善点の抽出
6. 修正・再テスト
```

### 10.4 パフォーマンステスト

#### 計測項目

```javascript
// ロード時間計測
performance.mark('app-start');
// アプリ起動
performance.mark('app-ready');
performance.measure('load-time', 'app-start', 'app-ready');

// メモリ使用量
console.log(performance.memory.usedJSHeapSize);

// FPS計測
let lastTime = performance.now();
const checkFPS = () => {
  const currentTime = performance.now();
  const fps = 1000 / (currentTime - lastTime);
  lastTime = currentTime;
  console.log('FPS:', fps);
  requestAnimationFrame(checkFPS);
};
```

---

## 11. リリース計画

### 11.1 開発フェーズ

#### フェーズ1: プロトタイプ（2週間）

**目標**: 基本的なゲームフローの実装

**タスク**:
- [x] プロジェクトセットアップ
- [ ] 基本UIの実装
- [ ] コアゲームロジック
- [ ] 簡易テスト

**成果物**:
- 動作するプロトタイプ
- 基本的なゲームフロー

#### フェーズ2: MVP（4週間）

**目標**: 必須機能の完全実装

**タスク**:
- [ ] 全画面の実装
- [ ] アニメーション追加
- [ ] データ保存機能
- [ ] 覗き見防止機能
- [ ] エラーハンドリング
- [ ] 内部テスト

**成果物**:
- リリース可能なMVP
- テストレポート

#### フェーズ3: ベータ版（2週間）

**目標**: ユーザーフィードバックの収集と改善

**タスク**:
- [ ] ベータテスター募集
- [ ] ユーザーテスト実施
- [ ] バグ修正
- [ ] UI/UX改善
- [ ] パフォーマンス最適化

**成果物**:
- 改善されたアプリ
- フィードバックレポート

#### フェーズ4: 正式リリース（1週間）

**目標**: 正式版の公開

**タスク**:
- [ ] 最終調整
- [ ] ドキュメント整備
- [ ] リリースノート作成
- [ ] プロモーション準備
- [ ] リリース

**成果物**:
- 正式版アプリ
- ユーザーガイド

### 11.2 マイルストーン

| マイルストーン | 期限 | 説明 |
|---------------|------|------|
| M1: プロトタイプ完成 | Week 2 | 基本フロー動作 |
| M2: MVP完成 | Week 6 | 全機能実装 |
| M3: ベータ版リリース | Week 8 | テスター公開 |
| M4: 正式リリース | Week 9 | 一般公開 |

### 11.3 リリース後の計画

#### バージョン1.1（+1ヶ月）

**追加機能**:
- ゲーム履歴表示
- 統計情報
- ダークモード

#### バージョン1.2（+2ヶ月）

**追加機能**:
- カスタムルール
- 多言語対応
- AI対戦モード

#### バージョン2.0（+6ヶ月）

**大型アップデート**:
- オンライン対戦
- フレンド機能
- 実績システム

---

## 12. 付録

### 12.1 用語集

| 用語 | 説明 |
|------|------|
| 出題者 | カードを選び、相手に渡すプレイヤー |
| 回答者 | カードを受け取り、判定または転送するプレイヤー |
| 宣言 | カードの種類を口頭（UI）で伝えること |
| 公開カード | 各プレイヤーの前に置かれた、全員が見えるカード |
| 手札 | 各プレイヤーが持つ、他人には見えないカード |
| ターン | 1枚のカードが誰かに引き取られるまでの一連の流れ |
| ブラフ | 嘘をつくこと |
| ポーカーフェイス | 表情を変えないこと |
| MVP | Minimum Viable Product（最小限の機能を持つ製品） |
| PWA | Progressive Web App |

### 12.2 FAQ

**Q: 手札がなくなったらどうなる？**  
A: 手札がなくなっても、次にカードを引き取るまではゲーム継続。引き取った時点で敗北。

**Q: 全員が同じカードを宣言し続けたら？**  
A: ゲームデザイン上、誰かが損をするので自然と分散される。

**Q: アプリが落ちたらゲームは最初から？**  
A: 自動保存機能により、最後のターンから再開可能。

**Q: オンライン対戦はできる？**  
A: 現バージョンではオフラインのみ。将来的にオンライン対応を検討。

**Q: iOSとAndroid両方で動く？**  
A: PWAの場合、両方で動作。ネイティブアプリの場合は個別開発が必要。

**Q: カードのデザインは変更できる？**  
A: 設定でテーマ変更機能を実装予定（優先度：中）

### 12.3 参考資料

#### ゲームデザイン
- 元ゲーム「ごきぶりポーカー」
- 類似ゲーム分析

#### 技術文書
- React公式ドキュメント
- PWA開発ガイド
- Web Animations API

#### デザインリソース
- Material Design
- iOS Human Interface Guidelines

### 12.4 変更履歴

| 日付 | バージョン | 変更内容 | 担当者 |
|------|-----------|---------|--------|
| 2025-01-XX | 1.0 | 初版作成 | - |
| 2025-01-XX | 1.1 | カード選択画面にOKボタン追加 | - |
| 2025-01-XX | 1.2 | 技術スタック更新（TypeScript + React Native + Supabase + Docker + Expo） | - |
| 2025-01-XX | 1.3 | 重要な仕様変更：回答者が他の人に渡す場合、カード確認を必須化 | - |
| 2025-01-XX | 1.3 | エッジケースの詳細処理を追加（同時敗北、手札0枚、全員が渡す等） | - |
| 2025-01-XX | 1.4 | 2人プレイ時の特殊ルール追加：10枚ランダム除外、54枚で27枚ずつ配布 | - |
| 2025-01-XX | 1.5 | Stripe決済システム実装（広告除去¥300買い切り） | - |
| 2025-01-XX | 1.5 | 8種類目の生物を「ムカデ」に決定 | - |
| 2025-01-XX | 1.6 | カード表示をビジュアル化：重なり表示+枚数表示で直感的に | - |
| 2025-01-XX | 1.7 | アプリ名を「PEST POKER（ペストポーカー）」に決定 | - |
| 2025-01-XX | 1.8 | 次の出題者ルールを明示化：カードを引き取った人が必ず次の出題者になる | - |
| 2025-01-XX | 1.9 | 出題時の順番を変更：1.誰に渡すか → 2.何を渡すか → 3.何を宣言するか | - |

### 12.5 連絡先・フィードバック

**バグ報告・機能要望**:
- GitHub Issues（プロジェクト公開後）
- メールアドレス（準備中）

**開発チーム**:
- プロジェクトリーダー: （未定）
- 開発者: （未定）
- デザイナー: （未定）

---

**以上、ブラフカードゲームアプリ仕様書 Version 1.0**

**最終更新**: 2025年1月  
**次回レビュー予定**: 開発開始後1週間